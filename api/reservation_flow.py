"""
Reservation flow system with intent detection, candidate suggestions, and confirmation
"""
import re
from typing import Dict, List, Optional, Any, Union
from datetime import datetime, timedelta
import json
import logging
from api.google_calendar import GoogleCalendarHelper

class ReservationFlow:
    def __init__(self):
        self.user_states = {}  # Store user reservation states
        self.google_calendar = GoogleCalendarHelper()  # Initialize Google Calendar integration
        self.line_configuration = None  # Will be set from main handler
        
        # Service and staff data for confirmation
        self.services = {
            "„Ç´„ÉÉ„Éà": {"duration": 60, "price": 3000},
            "„Ç´„É©„Éº": {"duration": 120, "price": 8000},
            "„Éë„Éº„Éû": {"duration": 150, "price": 12000},
            "„Éà„É™„Éº„Éà„É°„É≥„Éà": {"duration": 90, "price": 5000}
        }
        self.staff_members = {
            "Áî∞‰∏≠": {"specialty": "„Ç´„ÉÉ„Éà„Éª„Ç´„É©„Éº", "experience": "5Âπ¥"},
            "‰ΩêËó§": {"specialty": "„Éë„Éº„Éû„Éª„Éà„É™„Éº„Éà„É°„É≥„Éà", "experience": "3Âπ¥"},
            "Â±±Áî∞": {"specialty": "„Ç´„ÉÉ„Éà„Éª„Ç´„É©„Éº„Éª„Éë„Éº„Éû", "experience": "8Âπ¥"},
            "Êú™ÊåáÂÆö": {"specialty": "ÂÖ®Ëà¨", "experience": "ÊãÖÂΩìËÄÖÊ±∫ÂÆö"}
        }
    
    def _get_available_slots(self, start_date: datetime = None, days_ahead: int = 7) -> List[Dict[str, Any]]:
        """Get available time slots from Google Calendar"""
        if start_date is None:
            start_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        end_date = start_date + timedelta(days=days_ahead)
        return self.google_calendar.get_available_slots(start_date, end_date)
    
    def _create_calendar_template(self) -> str:
        """Create a professional 2-month weekday calendar for date selection"""
        # Get available dates for current month + next month (weekdays only)
        start_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        end_date = start_date + timedelta(days=60)  # 2 months ahead
        available_slots = self._get_available_slots(start_date, 60)
        
        # Group slots by date (weekdays only)
        available_dates = set()
        for slot in available_slots:
            if slot["available"]:
                date_str = slot["date"]
                date_obj = datetime.strptime(date_str, "%Y-%m-%d")
                # Only include weekdays (Monday=0 to Friday=4)
                if date_obj.weekday() < 5:  # Monday to Friday
                    available_dates.add(date_str)
        
        # Create professional calendar
        calendar_message = "üìÖ **„ÅîÂ∏åÊúõ„ÅÆÊó•‰ªò„Çí„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ**\n\n"
        
        # Show current month and next month
        current_month = start_date.month
        current_year = start_date.year
        next_month = current_month + 1 if current_month < 12 else 1
        next_year = current_year if current_month < 12 else current_year + 1
        
        month_names = ["1Êúà", "2Êúà", "3Êúà", "4Êúà", "5Êúà", "6Êúà", 
                      "7Êúà", "8Êúà", "9Êúà", "10Êúà", "11Êúà", "12Êúà"]
        
        # Current month
        calendar_message += f"üóìÔ∏è **{current_year}Âπ¥ {month_names[current_month-1]}**\n"
        calendar_message += self._create_weekday_calendar(current_year, current_month, available_dates)
        
        # Next month
        calendar_message += f"\nüóìÔ∏è **{next_year}Âπ¥ {month_names[next_month-1]}**\n"
        calendar_message += self._create_weekday_calendar(next_year, next_month, available_dates)
        
        calendar_message += "\n" + "="*30 + "\n"
        calendar_message += "üí° **Âà©Áî®ÂèØËÉΩ„Å™Êó•‰ªò„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ**\n"
        calendar_message += "üìù ‰æãÔºö`[15]` „Çí„ÇØ„É™„ÉÉ„ÇØ\n"
        calendar_message += "‚ùå ‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„Åô„ÇãÂ†¥Âêà„ÅØ„Äå„Ç≠„É£„É≥„Çª„É´„Äç„Å®ÈÄÅ‰ø°"
        
        return calendar_message
    
    def _create_weekday_calendar(self, year: int, month: int, available_dates: set) -> str:
        """Create a weekday-only calendar for a specific month"""
        # Get first day of month
        first_day = datetime(year, month, 1)
        last_day = (first_day.replace(month=month % 12 + 1, day=1) - timedelta(days=1)).day
        
        # Weekday headers (Monday to Friday only)
        weekdays = [" Êúà ", " ÁÅ´ ", " Ê∞¥ ", " Êú® ", " Èáë "]
        calendar = "   " + " ".join([f"{day:>3}" for day in weekdays]) + "\n"
        
        # Find first weekday of the month
        first_weekday = first_day.weekday()  # Monday = 0, Sunday = 6
        
        # Start from the first Monday of the week containing the 1st
        start_date = first_day - timedelta(days=first_weekday)
        
        # Create calendar grid (weekdays only)
        current_date = start_date
        week_count = 0
        
        while current_date.month <= month and week_count < 6:  # Max 6 weeks
            week_line = "   "
            for day_offset in range(5):  # Monday to Friday only
                check_date = current_date + timedelta(days=day_offset)
                
                if check_date.month == month and 1 <= check_date.day <= last_day:
                    day = check_date.day
                    date_str = f"{year}-{month:02d}-{day:02d}"
                    
                    if date_str in available_dates:
                        # Available date - clickable
                        week_line += f"[{day:2d}] "
                    else:
                        # Unavailable date
                        week_line += f" {day:2d}  "
                else:
                    # Empty cell
                    week_line += "    "
            
            # Only add line if it has content for this month
            if any(1 <= (current_date + timedelta(days=i)).day <= last_day 
                   for i in range(5) if (current_date + timedelta(days=i)).month == month):
                calendar += week_line.rstrip() + "\n"
            
            current_date += timedelta(days=7)  # Next week
            week_count += 1
        
        return calendar
    
    def detect_intent(self, message: str, user_id: str = None) -> str:
        """Detect user intent from message with context awareness"""
        message_lower = message.lower()
        
        # Check if user is in reservation flow
        if user_id and user_id in self.user_states:
            state = self.user_states[user_id]
            step = state["step"]
            
            # During other reservation steps, treat as reservation flow
            if step in ["service_selection", 'staff_selection', "date_selection", "time_selection", "confirmation"]:
                return "reservation_flow"
        
        # Reservation intent keywords (only when not in flow)
        reservation_keywords = [
            "‰∫àÁ¥Ñ", "‰∫àÁ¥Ñ„Åó„Åü„ÅÑ", "‰∫àÁ¥Ñ„ÅäÈ°ò„ÅÑ", "‰∫àÁ¥Ñ„Åß„Åç„Åæ„Åô„Åã",
            "Á©∫„ÅÑ„Å¶„Çã", "Á©∫„Åç", "ÊôÇÈñì", "„ÅÑ„Å§", "ÂèØËÉΩ"
        ]
        
        # Cancel intent keywords
        cancel_keywords = [
            "„Ç≠„É£„É≥„Çª„É´", "Âèñ„ÇäÊ∂à„Åó", "„ÇÑ„ÇÅ„Çã", "‰∏≠Ê≠¢"
        ]
        
        # Modify intent keywords
        modify_keywords = [
            "‰∫àÁ¥ÑÂ§âÊõ¥", "Â§âÊõ¥", "‰øÆÊ≠£", "ÊôÇÈñìÂ§âÊõ¥", "Êó•ÊôÇÂ§âÊõ¥", "‰∫àÁ¥Ñ‰øÆÊ≠£"
        ]
        
        # Priority order: reservation > service_selection > staff_selection > modify > cancel
        if any(keyword in message_lower for keyword in reservation_keywords):
            return "reservation"
        elif any(keyword in message_lower for keyword in modify_keywords):
            return "modify"
        elif any(keyword in message_lower for keyword in cancel_keywords):
            return "cancel"
        else:
            return "general"
    
    def handle_reservation_flow(self, user_id: str, message: str) -> str:
        """Handle the complete reservation flow"""
        if user_id not in self.user_states:
            self.user_states[user_id] = {"step": "start", "data": {}}
        
        # Check for cancellation at any step
        if message.lower() in ["„Ç≠„É£„É≥„Çª„É´", "Âèñ„ÇäÊ∂à„Åó", "„ÇÑ„ÇÅ„Çã", "‰∏≠Ê≠¢"]:
            del self.user_states[user_id]
            return "‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
        
        state = self.user_states[user_id]
        step = state["step"]
        
        if step == "start":
            return self._start_reservation(user_id)
        elif step == "service_selection":
            return self._handle_service_selection(user_id, message)
        elif step == "staff_selection":
            return self._handle_staff_selection(user_id, message)
        elif step == "date_selection":
            return self._handle_date_selection(user_id, message)
        elif step == "time_selection":
            return self._handle_time_selection(user_id, message)
        elif step == "confirmation":
            return self._handle_confirmation(user_id, message)
        else:
            return "‰∫àÁ¥Ñ„Éï„É≠„Éº„Å´ÂïèÈ°å„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÊúÄÂàù„Åã„Çâ„ÇÑ„ÇäÁõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
    
    def _start_reservation(self, user_id: str) -> str:
        """Start reservation process"""
        self.user_states[user_id]["step"] = "service_selection"
        return """„Åî‰∫àÁ¥Ñ„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ
„Å©„ÅÆ„Çµ„Éº„Éì„Çπ„Çí„ÅîÂ∏åÊúõ„Åß„Åô„ÅãÔºü

„Éª„Ç´„ÉÉ„ÉàÔºà60ÂàÜ„Éª3,000ÂÜÜÔºâ
„Éª„Ç´„É©„ÉºÔºà120ÂàÜ„Éª8,000ÂÜÜÔºâ
„Éª„Éë„Éº„ÉûÔºà150ÂàÜ„Éª12,000ÂÜÜÔºâ
„Éª„Éà„É™„Éº„Éà„É°„É≥„ÉàÔºà90ÂàÜ„Éª5,000ÂÜÜÔºâ

„Çµ„Éº„Éì„ÇπÂêç„Çí„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ

‚Äª‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÇãÂ†¥Âêà„ÅØ„Äå„Ç≠„É£„É≥„Çª„É´„Äç„Å®„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ"""
    
    def _handle_service_selection(self, user_id: str, message: str) -> str:
        """Handle service selection"""
        # Check for cancellation first
        if message.lower() in ["„Ç≠„É£„É≥„Çª„É´", "Âèñ„ÇäÊ∂à„Åó", "„ÇÑ„ÇÅ„Çã", "‰∏≠Ê≠¢"]:
            del self.user_states[user_id]
            return "‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
        
        selected_service = None
        message_lower = message.lower()
        
        # More flexible service matching
        service_mapping = {
            "„Ç´„ÉÉ„Éà": "„Ç´„ÉÉ„Éà",
            "„Ç´„É©„Éº": "„Ç´„É©„Éº", 
            "„Éë„Éº„Éû": "„Éë„Éº„Éû",
            "„Éà„É™„Éº„Éà„É°„É≥„Éà": "„Éà„É™„Éº„Éà„É°„É≥„Éà",
            "cut": "„Ç´„ÉÉ„Éà",
            "color": "„Ç´„É©„Éº",
            "perm": "„Éë„Éº„Éû",
            "treatment": "„Éà„É™„Éº„Éà„É°„É≥„Éà"
        }
        
        for keyword, service_name in service_mapping.items():
            if keyword in message_lower:
                selected_service = service_name
                break
        
        if not selected_service:
            return "Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅ„Åù„ÅÆ„Çµ„Éº„Éì„Çπ„ÅØÊèê‰æõ„Åó„Å¶„Åä„Çä„Åæ„Åõ„Çì„ÄÇ‰∏äË®ò„ÅÆ„Çµ„Éº„Éì„Çπ„Åã„Çâ„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ"
        
        self.user_states[user_id]["data"]["service"] = selected_service
        self.user_states[user_id]["step"] = "staff_selection"
        
        return f"""{selected_service}„Åß„Åô„Å≠ÔºÅ
ÊãÖÂΩì„ÅÆÁæéÂÆπÂ∏´„Çí„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ

„ÉªÁî∞‰∏≠Ôºà„Ç´„ÉÉ„Éà„Éª„Ç´„É©„ÉºÂ∞ÇÈñÄ„Éª5Âπ¥ÁµåÈ®ìÔºâ
„Éª‰ΩêËó§Ôºà„Éë„Éº„Éû„Éª„Éà„É™„Éº„Éà„É°„É≥„ÉàÂ∞ÇÈñÄ„Éª3Âπ¥ÁµåÈ®ìÔºâ
„ÉªÂ±±Áî∞ÔºàÂÖ®Ëà¨ÂØæÂøú„Éª8Âπ¥ÁµåÈ®ìÔºâ
„ÉªÊú™ÊåáÂÆöÔºàÊãÖÂΩìËÄÖÊ±∫ÂÆöÔºâ

ÁæéÂÆπÂ∏´Âêç„Çí„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ

‚Äª‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÇãÂ†¥Âêà„ÅØ„Äå„Ç≠„É£„É≥„Çª„É´„Äç„Å®„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ"""
    
    def _handle_staff_selection(self, user_id: str, message: str) -> str:
        """Handle staff selection"""
        # Check for cancellation first
        if message.lower() in ["„Ç≠„É£„É≥„Çª„É´", "Âèñ„ÇäÊ∂à„Åó", "„ÇÑ„ÇÅ„Çã", "‰∏≠Ê≠¢"]:
            del self.user_states[user_id]
            return "‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
        
        selected_staff = None
        message_lower = message.lower()
        
        # Staff matching
        staff_mapping = {
            "Áî∞‰∏≠": "Áî∞‰∏≠",
            "‰ΩêËó§": "‰ΩêËó§", 
            "Â±±Áî∞": "Â±±Áî∞",
            "Êú™ÊåáÂÆö": "Êú™ÊåáÂÆö",
            "ÊãÖÂΩìËÄÖ": "Êú™ÊåáÂÆö",
            "ÁæéÂÆπÂ∏´": "Êú™ÊåáÂÆö"
        }
        
        for keyword, staff_name in staff_mapping.items():
            if keyword in message_lower:
                selected_staff = staff_name
                break
        
        if not selected_staff:
            return "Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅ„Åù„ÅÆÁæéÂÆπÂ∏´„ÅØÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„Çì„ÄÇ‰∏äË®ò„ÅÆÁæéÂÆπÂ∏´„Åã„Çâ„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ"
        
        self.user_states[user_id]["data"]["staff"] = selected_staff
        self.user_states[user_id]["step"] = "date_selection"
        
        # Add "„Åï„Çì" only for specific staff members, not for "Êú™ÊåáÂÆö"
        staff_display = f"{selected_staff}„Åï„Çì" if selected_staff != "Êú™ÊåáÂÆö" else selected_staff
        
        # Return calendar template for date selection
        return self._create_calendar_template()
    
    def _handle_date_selection(self, user_id: str, message: str) -> str:
        """Handle date selection from calendar template"""
        # Check for cancellation first
        if message.lower() in ["„Ç≠„É£„É≥„Çª„É´", "Âèñ„ÇäÊ∂à„Åó", "„ÇÑ„ÇÅ„Çã", "‰∏≠Ê≠¢"]:
            del self.user_states[user_id]
            return "‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
        
        # Parse date from calendar template response
        selected_date = None
        
        # Try to parse YYYY-MM-DD format (from calendar template)
        date_match = re.search(r'(\d{4}-\d{2}-\d{2})', message)
        if date_match:
            selected_date = date_match.group(1)
        else:
            # Try to parse clickable date format [DD] from calendar
            clickable_match = re.search(r'\[(\d{1,2})\]', message)
            if clickable_match:
                day = int(clickable_match.group(1))
                current_date = datetime.now()
                # Create the date for this month
                try:
                    selected_date = f"{current_date.year}-{current_date.month:02d}-{day:02d}"
                    # Validate the date exists
                    datetime.strptime(selected_date, "%Y-%m-%d")
                except ValueError:
                    selected_date = None
            else:
                # Fallback to old text-based parsing for backward compatibility
                if "ÊòéÊó•" in message:
                    selected_date = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
                elif "ÊòéÂæåÊó•" in message:
                    selected_date = (datetime.now() + timedelta(days=2)).strftime("%Y-%m-%d")
                elif "ÂúüÊõúÊó•" in message or "ÂúüÊõú" in message:
                    # Find next Saturday
                    days_ahead = 5 - datetime.now().weekday()  # Saturday is 5
                    if days_ahead <= 0:
                        days_ahead += 7
                    selected_date = (datetime.now() + timedelta(days=days_ahead)).strftime("%Y-%m-%d")
        
        if not selected_date:
            return "Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅ„Åù„ÅÆÊó•‰ªò„ÅØÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„Çì„ÄÇ‰∏äË®ò„ÅÆÊó•‰ªò„Åã„Çâ„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ"
        
        self.user_states[user_id]["data"]["date"] = selected_date
        self.user_states[user_id]["step"] = "time_selection"
        
        # Get available times for selected date from Google Calendar
        available_slots = self._get_available_slots()
        available_times = [slot["time"] for slot in available_slots 
                          if slot["date"] == selected_date and slot["available"]]
        
        if not available_times:
            return f"Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅ{selected_date}„ÅØÁ©∫„ÅÑ„Å¶„ÅÑ„ÇãÊôÇÈñì„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ‰ªñ„ÅÆÊó•‰ªò„Çí„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ"
        
        return f"""{selected_date}„Åß„Åô„Å≠ÔºÅ
Á©∫„ÅÑ„Å¶„ÅÑ„ÇãÊôÇÈñìÂ∏Ø„ÅØ‰ª•‰∏ã„ÅÆÈÄö„Çä„Åß„ÅôÔºö

{chr(10).join([f"„Éª{time}" for time in available_times])}

„ÅîÂ∏åÊúõ„ÅÆÊôÇÈñì„Çí„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ

‚Äª‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÇãÂ†¥Âêà„ÅØ„Äå„Ç≠„É£„É≥„Çª„É´„Äç„Å®„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ"""
    
    def _handle_time_selection(self, user_id: str, message: str) -> str:
        """Handle time selection"""
        # Check for cancellation first
        if message.lower() in ["„Ç≠„É£„É≥„Çª„É´", "Âèñ„ÇäÊ∂à„Åó", "„ÇÑ„ÇÅ„Çã", "‰∏≠Ê≠¢"]:
            del self.user_states[user_id]
            return "‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
        
        selected_date = self.user_states[user_id]["data"]["date"]
        available_slots = self._get_available_slots()
        available_times = [slot["time"] for slot in available_slots 
                         if slot["date"] == selected_date and slot["available"]]

        # Normalize the input message
        normalized_message = message.strip()
        
        # Check if input is a valid time format
        is_valid_time = False
        selected_time = None
        
        # Convert various time formats to standard HH:MM format
        # Handle "10ÊôÇ" -> "10:00"
        if re.match(r'^(\d{1,2})ÊôÇ$', normalized_message):
            hour = int(re.match(r'^(\d{1,2})ÊôÇ$', normalized_message).group(1))
            if 0 <= hour <= 23:
                normalized_message = f"{hour:02d}:00"
                is_valid_time = True
        # Handle "10ÊôÇ30ÂàÜ" -> "10:30"
        elif re.match(r'^(\d{1,2})ÊôÇ(\d{1,2})ÂàÜ?$', normalized_message):
            match = re.match(r'^(\d{1,2})ÊôÇ(\d{1,2})ÂàÜ?$', normalized_message)
            hour = int(match.group(1))
            minute = int(match.group(2))
            if 0 <= hour <= 23 and 0 <= minute <= 59:
                normalized_message = f"{hour:02d}:{minute:02d}"
                is_valid_time = True
        # Handle "10" -> "10:00"
        elif re.match(r'^(\d{1,2})$', normalized_message):
            hour = int(re.match(r'^(\d{1,2})$', normalized_message).group(1))
            if 0 <= hour <= 23:
                normalized_message = f"{hour:02d}:00"
                is_valid_time = True
        # Handle "10:30" or "10:30ÂàÜ" -> "10:30"
        elif re.match(r'^(\d{1,2}):(\d{1,2})ÂàÜ?$', normalized_message):
            match = re.match(r'^(\d{1,2}):(\d{1,2})ÂàÜ?$', normalized_message)
            hour = int(match.group(1))
            minute = int(match.group(2))
            if 0 <= hour <= 23 and 0 <= minute <= 59:
                normalized_message = f"{hour:02d}:{minute:02d}"
                is_valid_time = True
        # Handle "10Ôºö30" (full-width colon)
        elif re.match(r'^(\d{1,2})Ôºö(\d{1,2})ÂàÜ?$', normalized_message):
            match = re.match(r'^(\d{1,2})Ôºö(\d{1,2})ÂàÜ?$', normalized_message)
            hour = int(match.group(1))
            minute = int(match.group(2))
            if 0 <= hour <= 23 and 0 <= minute <= 59:
                normalized_message = f"{hour:02d}:{minute:02d}"
                is_valid_time = True
        
        # If input is not a valid time format, return error message
        if not is_valid_time:
            return """ÊôÇÈñì„ÅÆÂÖ•ÂäõÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ

Ê≠£„Åó„ÅÑÂÖ•Âäõ‰æãÔºö
„Éª10ÊôÇ
„Éª15ÊôÇ30ÂàÜ
„Éª14:00
„Éª9

‰∏äË®ò„ÅÆÁ©∫„ÅçÊôÇÈñì„Åã„Çâ„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ"""

        # Check if the normalized time is available
        if normalized_message in available_times:
            selected_time = normalized_message
        else:
            return f"Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅ{normalized_message}„ÅØÁ©∫„ÅÑ„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰∏äË®ò„ÅÆÁ©∫„ÅçÊôÇÈñì„Åã„Çâ„ÅäÈÅ∏„Å≥„Åè„Å†„Åï„ÅÑ„ÄÇ"
        
        self.user_states[user_id]["data"]["time"] = selected_time
        self.user_states[user_id]["step"] = "confirmation"
        
        service = self.user_states[user_id]["data"]["service"]
        staff = self.user_states[user_id]["data"]["staff"]
        service_info = self.services[service]
        
        return f"""‰∫àÁ¥ÑÂÜÖÂÆπ„ÅÆÁ¢∫Ë™ç„Åß„ÅôÔºö

üìÖ Êó•ÊôÇÔºö{selected_date} {selected_time}
üíá „Çµ„Éº„Éì„ÇπÔºö{service}
üë®‚Äçüíº ÊãÖÂΩìËÄÖÔºö{staff}
‚è±Ô∏è ÊâÄË¶ÅÊôÇÈñìÔºö{service_info['duration']}ÂàÜ
üí∞ ÊñôÈáëÔºö{service_info['price']:,}ÂÜÜ

„Åì„ÅÆÂÜÖÂÆπ„Åß‰∫àÁ¥Ñ„ÇíÁ¢∫ÂÆö„Åó„Åæ„Åô„ÅãÔºü
„Äå„ÅØ„ÅÑ„Äç„Åæ„Åü„ÅØ„ÄåÁ¢∫ÂÆö„Äç„Å®„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ

‚Äª‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÇãÂ†¥Âêà„ÅØ„Äå„Ç≠„É£„É≥„Çª„É´„Äç„Å®„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ"""

    def _handle_confirmation(self, user_id: str, message: str) -> str:
        """Handle final confirmation"""
        if "„ÅØ„ÅÑ" in message or "Á¢∫ÂÆö" in message or "„ÅäÈ°ò„ÅÑ" in message:
            # Complete the reservation
            reservation_data = self.user_states[user_id]["data"].copy()
            del self.user_states[user_id]  # Clear user state
            
            # Get client display name
            client_name = self._get_line_display_name(user_id)
            
            # Create calendar event immediately
            calendar_success = self.google_calendar.create_reservation_event(
                reservation_data, 
                client_name
            )
            
            if not calendar_success:
                logging.warning(f"Failed to create calendar event for user {user_id}")
           
            return f"""‚úÖ ‰∫àÁ¥Ñ„ÅåÁ¢∫ÂÆö„ÅÑ„Åü„Åó„Åæ„Åó„ÅüÔºÅ

üìÖ Êó•ÊôÇÔºö{reservation_data['date']} {reservation_data['time']}
üíá „Çµ„Éº„Éì„ÇπÔºö{reservation_data['service']}
üë®‚Äçüíº ÊãÖÂΩìËÄÖÔºö{reservation_data['staff']}

ÂΩìÊó•„ÅØ„ÅäÊôÇÈñì„Åæ„Åß„Å´„ÅäË∂ä„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åî‰∫àÁ¥Ñ„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åó„ÅüÔºÅ"""
        else:
            return "‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
    
    def get_response(self, user_id: str, message: str) -> str:
        """Main entry point for reservation flow"""
        intent = self.detect_intent(message, user_id)
        
        if intent == "reservation":
            return self.handle_reservation_flow(user_id, message)
        elif intent == "reservation_flow":
            return self.handle_reservation_flow(user_id, message)
        elif intent == "modify":
            return self._handle_modify_request(user_id, message)
        elif intent == "cancel":
            return self._handle_cancel_request(user_id)
        else:
            return None  # Let other systems handle this

    def set_line_configuration(self, configuration):
        """Set LINE configuration for getting display names"""
        self.line_configuration = configuration
    
    def _get_line_display_name(self, user_id: str) -> str:
        """Get LINE display name for the user"""
        if not self.line_configuration:
            return "„ÅäÂÆ¢Êßò"  # Fallback name
        
        try:
            from linebot.v3.messaging import ApiClient, MessagingApi
            with ApiClient(self.line_configuration) as api_client:
                line_bot_api = MessagingApi(api_client)
                profile = line_bot_api.get_profile(user_id)
                return profile.display_name
        except Exception as e:
            logging.error(f"Failed to get LINE display name: {e}")
            return "„ÅäÂÆ¢Êßò"  # Fallback name

    def _handle_cancel_request(self, user_id: str) -> str:
        """Cancel existing calendar reservation for the user if present."""
        client_name = self._get_line_display_name(user_id)
        try:
            success = self.google_calendar.cancel_reservation(client_name)
            if success:
                return "„Åî‰∫àÁ¥Ñ„ÅÆ„Ç≠„É£„É≥„Çª„É´„ÇíÊâø„Çä„Åæ„Åó„Åü„ÄÇ\n„Åæ„Åü„ÅÆ„ÅîÂà©Áî®„Çí„ÅäÂæÖ„Å°„Åó„Å¶„Åä„Çä„Åæ„Åô„ÄÇ"
            else:
                return "ÁèæÂú®„ÄÅÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åî‰∫àÁ¥Ñ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ\nÂà•„ÅÆ„ÅäÂêçÂâç„Åß„Åî‰∫àÁ¥Ñ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Çπ„Çø„ÉÉ„Éï„Åæ„Åß„ÅäÁü•„Çâ„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ"
        except Exception as e:
            logging.error(f"Cancel request failed: {e}")
            return "Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Ç≠„É£„É≥„Çª„É´„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂ∞ë„ÅóÊôÇÈñì„ÇíÁΩÆ„ÅÑ„Å¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ"

    def _parse_datetime_from_text(self, text: str) -> Optional[Dict[str, str]]:
        """Parse date and time from user text. Expected format: YYYY-MM-DD HH:MM.
        Returns dict with keys 'date' and 'time' if both found, else None.
        """
        text = text.strip()
        # Try pattern: 2025-10-07 14:30
        match = re.search(r"(\d{4}-\d{2}-\d{2})\s+(\d{1,2}):(\d{2})", text)
        if match:
            date_part = match.group(1)
            hour = int(match.group(2))
            minute = int(match.group(3))
            if 0 <= hour <= 23 and 0 <= minute <= 59:
                return {"date": date_part, "time": f"{hour:02d}:{minute:02d}"}

        # Try Japanese style like "10Êúà7Êó• 14ÊôÇ30ÂàÜ" ‚Üí require conversion; keep simple for now
        match2 = re.search(r"(\d{4})Âπ¥(\d{1,2})Êúà(\d{1,2})Êó•\s*(\d{1,2})ÊôÇ(\d{1,2})?ÂàÜ?", text)
        if match2:
            y = int(match2.group(1))
            m = int(match2.group(2))
            d = int(match2.group(3))
            hh = int(match2.group(4))
            mm = int(match2.group(5) or 0)
            if 1 <= m <= 12 and 1 <= d <= 31 and 0 <= hh <= 23 and 0 <= mm <= 59:
                return {"date": f"{y:04d}-{m:02d}-{d:02d}", "time": f"{hh:02d}:{mm:02d}"}

        return None

    def _handle_modify_request(self, user_id: str, message: str) -> str:
        """Modify existing reservation time via Google Calendar.

        Conversation flow:
        - If we don't yet have new date/time, ask for it in the format "YYYY-MM-DD HH:MM".
        - Once received, perform modification on the user's upcoming reservation.
        """
        state = self.user_states.get(user_id)
        if not state or state.get("step") not in ["modify_waiting", "modify_provide_time"]:
            # Start modify flow
            self.user_states[user_id] = {"step": "modify_waiting"}
            return "„Åî‰∫àÁ¥Ñ„ÅÆÂ§âÊõ¥„Åß„Åô„Å≠„ÄÇ\nÊñ∞„Åó„ÅÑÊó•ÊôÇ„Çí \"YYYY-MM-DD HH:MM\" „ÅÆÂΩ¢Âºè„Åß„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ\n‰æãÔºâ2025-10-07 14:30"

        # Try to parse date/time from message
        parsed = self._parse_datetime_from_text(message)
        if not parsed:
            return "Êó•ÊôÇ„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ\n\"YYYY-MM-DD HH:MM\" „ÅÆÂΩ¢Âºè„Åß„ÅäÈÄÅ„Çä„Åè„Å†„Åï„ÅÑ„ÄÇ\n‰æãÔºâ2025-10-07 14:30"

        new_date = parsed["date"]
        new_time = parsed["time"]
        client_name = self._get_line_display_name(user_id)
        try:
            success = self.google_calendar.modify_reservation_time(client_name, new_date, new_time)
            # Clear temporary modify state
            if user_id in self.user_states and self.user_states[user_id].get("step","") in ["modify_waiting", "modify_provide_time"]:
                del self.user_states[user_id]
            if success:
                return f"„Åî‰∫àÁ¥Ñ„ÅÆÊó•ÊôÇ„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü„ÄÇ\nüìÖ Êñ∞„Åó„ÅÑÊó•ÊôÇÔºö{new_date} {new_time}"
            else:
                return "ÁèæÂú®„ÄÅÂ§âÊõ¥„Åß„Åç„Çã„Åî‰∫àÁ¥Ñ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ\nÂà•„ÅÆ„ÅäÂêçÂâç„Åß„Åî‰∫àÁ¥Ñ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Çπ„Çø„ÉÉ„Éï„Åæ„Åß„ÅäÁü•„Çâ„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ"
        except Exception as e:
            logging.error(f"Modify request failed: {e}")
            return "Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇÂ§âÊõ¥„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂ∞ë„ÅóÊôÇÈñì„ÇíÁΩÆ„ÅÑ„Å¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ"
